<html lang="en">
  <head>
    <title>Object Collision Simulator</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      body {
        color: #61443e;
        font-family: Monospace;
        font-size: 13px;
        text-align: center;

        background-color: #bfd1e5;
        margin: 0px;
        overflow: hidden;
      }

      #info {
        position: absolute;
        top: 0px;
        width: 100%;
        padding: 5px;
      }

      a {
        color: #a06851;
      }
    </style>
  </head>

  <body>
    <div id="info">Press mb1 to throw the cannon ball...</div>
    <div id="container"><br /><br /><br /><br /><br />Loading...</div>

    <script src="js/three.js"></script>
    <script src="js/libs/ammo.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/WebGL.js"></script>
    <script src="js/libs/stats.min.js"></script>

    <script>
      // Detects webgl

      if (WEBGL.isWebGLAvailable() === false) {
        document.body.appendChild(WEBGL.getWebGLErrorMessage());
        document.getElementById("container").innerHTML = "";
      }

      // Graphics variables
      var container, stats;
      var camera, controls, scene, renderer;
      var textureLoader;
      var clock = new THREE.Clock();

      // Number of bricks
      var numOfBricks = 60;
      
      // Physics variables
      var gravityConstant = -9.8;
      var bricks = [];
      var collisionMargin = 0.005;
      var physicsWorld;


      init();
      animate();

      // Runs all our inital setup
      function init() {
        initGraphics(); // Camera and light setup.
        initInput(); // Inits our input (For shooting the cannon ball)

        // Object creation
        var floor = createFloor(1000, 1000) // (floorWidth, floorDepth) -> Floor object
        createBricks(numOfBricks, floor); // Creates the bricks on our floor and adds all of them to the bricks array
        //createBall() // Temporary as we are launching a ball later on so it should not be "spawned" like it is in its current state

        // initObjects(); // This function should contain all our intial objects (Bricks and floor) -> The ball will be rendered on keyDown/keyUp
        // initPhysics(); // We need to implement our own physics and collision detection -> This should just give bodies physics attributes
      }

      function initGraphics() {
        container = document.getElementById("container");

        camera = new THREE.PerspectiveCamera(
          80,
          window.innerWidth / window.innerHeight,
        );
        

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xbfd1e5);

        camera.position.set(-100, 200, -100);

        controls = new THREE.OrbitControls(camera);
        controls.target.set(0, 2, 0);
        controls.update();

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        textureLoader = new THREE.TextureLoader();

        var ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        var light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(-10, 10, 5);
        light.castShadow = true;
        var d = 10;
        light.shadow.camera.left = -d;
        light.shadow.camera.right = d;
        light.shadow.camera.top = d;
        light.shadow.camera.bottom = -d;

        light.shadow.camera.near = 2;
        light.shadow.camera.far = 50;

        light.shadow.mapSize.x = 1024;
        light.shadow.mapSize.y = 1024;

        scene.add(light);

        container.innerHTML = "";

        container.appendChild(renderer.domElement);

        stats = new Stats();
        stats.domElement.style.position = "absolute";
        stats.domElement.style.top = "0px";
        container.appendChild(stats.domElement);

        //

        window.addEventListener("resize", onWindowResize, false);
      }
      
      function initInput() {
        window.addEventListener(
          "keydown",
          function(event) {
            switch (event.keyCode) {
              // Q
              case 81:
                // armMovement = 1;
                break;

              // A
              case 65:
                // armMovement = -1;
                break;
            }
          },
          false
        );

        window.addEventListener(
          "keyup",
          function() {
            // armMovement = 0;
          },
          false
        );
      }

      function createRandomColor() {
        return Math.floor(Math.random() * (1 << 24));
      }

      function createMaterial() {
        return new THREE.MeshPhongMaterial({ color: createRandomColor() });
      }

      function createBricks(numOfBricks, floor) {
        // This creates numOfBricks bricks and appends it to the bricks array
        for(let i = 0; i < numOfBricks; i++) {
          
          brickWidth = 10;
          brickHeight = 5;
          brickDepth = 5;
          // Creating a brick
          var brick = new THREE.Mesh(
            new THREE.BoxBufferGeometry(brickWidth, brickHeight, brickDepth), // Same size on all bricks
            createMaterial() // Randomized color
          );
          // We can use userData to append any information we want
          // An example of this is the objects velocity and roation
          brick.userData.vel = new THREE.Vector3(0, 0, 0) // Initalizes velocity vector
<<<<<<< HEAD
          brick.userData.rot = new THREE.Vector3(0, 0, 0) // Initalizes rotation vector
=======
          brick.userData.acc = new THREE.Vector3(0, 0, 0) // Initalizes acceleration vector
          brick.userData.rotation = new THREE.Vector3(0, 0, 0) // Initalizes rotation vector
>>>>>>> 7e0157a9a63c831a3060a5c55d8d69b38ab7b081
          brick.userData.mass = 2 // Sets object mass -> TODO: Randomized mass within a resonable range
          // Add: Inertia, Friction coeffficient etc...

          // Sets the bricks position
          //TODO: Blacklist already randomized positions to maker sure bricks don't spawn witith other bricks
          brick.position.x = Math.floor(Math.random() * (floor.userData.width/2 - (-floor.userData.width/2)) + (-floor.userData.width/2)) // Our floor is a square -> Random * (Max - Min) + Min
          brick.position.y =  brickHeight/2 + collisionMargin + 10.0; // Half the height of the brick + a margin to avoid clipping
          brick.position.z = Math.floor(Math.random() * (floor.userData.depth/2 - (-floor.userData.depth/2)) + -floor.userData.depth/2) // Our floor is a square -> Random * (Max - Min) + Min

          scene.add(brick)
          bricks.push(brick)
        }
      }

      function createBall() {
        var ballRadius = 3;

        // Creating a ball
        var ball = new THREE.Mesh(
          new THREE.SphereBufferGeometry(ballRadius, 20, 20),
          new THREE.MeshPhongMaterial({ color: 0x202020 })
        );
        ball.position.y = ballRadius + collisionMargin // Static starting position. Modify this function to "launch" ball from the camera
    
        scene.add(ball)
      }

      function createFloor(floorWidth, floorDepth) {
        var floor = new THREE.Mesh(
          new THREE.PlaneBufferGeometry(floorWidth, floorDepth, 8, 8),
          new THREE.MeshPhongMaterial({ color: 0xffffff })
        );
        floor.material.side = 2 // Tells the renderer to show both sides of the floor
        floor.rotation.x = Math.PI/2

        // So we can use the width in the randomizers
        floor.userData.width = floorWidth
        floor.userData.depth = floorDepth

        scene.add(floor)
        return floor
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        render();
      }

      function render() {
        var deltaTime = clock.getDelta();
        //console.log(deltaTime)
        //updatePhysics(deltaTime);

        // This should not be done in the render function like this.
        // This should be abstracted into a function: updateBricks() or something
        for (let i = 0; i < bricks.length; i++) {

          updatePhysics();
          //bricks[i] // This lets you access each brick and do operations on it
          //bricks[i].userData.vel.y += 0.01
          //bricks[i].translateY(bricks[i].userData.vel.y)
        }
       // brick.translateX(brick.userData.vel.x) // Movement example
       // brick.translateY(brick.userData.vel.y) // Movement example
       // brick.translateZ(brick.userData.vel.z) // Movement example

       // brick.rotateX(brick.userData.rotation.x) // Rotation Example
       // brick.rotateY(brick.userData.rotation.y) // Rotation Example
       // brick.rotateZ(brick.userData.rotation.z) // Rotation Example

        renderer.render(scene, camera);
      }

      function updatePhysics(deltaTime) {

        // Step world
        physicsWorld.stepSimulation(deltaTime, 10);

        // This should not be done in the render function like this.
        // This should be abstracted into a function: updateBricks() or something
        for (let i = 0; i < bricks.length; i++) {

          //bricks[i] // This lets you access each brick and do operations on it
          bricks[i].userData.vel.y += 0.01
          bricks[i].translateY(bricks[i].userData.vel.y)
        }
    
      }
    </script>
  </body>
</html>



