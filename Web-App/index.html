<html lang="en">
  <head>
    <title>Object Collision Simulator</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      body {
        color: #61443e;
        font-family: Monospace;
        font-size: 13px;
        text-align: center;

        background-color: #bfd1e5;
        margin: 0px;
        overflow: hidden;
      }

      #info {
        position: absolute;
        top: 0px;
        width: 100%;
        padding: 5px;
      }

      a {
        color: #a06851;
      }
    </style>
  </head>

  <body>
    <div id="info">Press mb1 to throw the cannon ball...</div>
    <div id="container"><br /><br /><br /><br /><br />Loading...</div>

    <script src="js/three.js"></script>
    <script src="js/libs/ammo.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/WebGL.js"></script>
    <script src="js/libs/stats.min.js"></script>

    <script>
      // Detects webgl

      if (WEBGL.isWebGLAvailable() === false) {
        document.body.appendChild(WEBGL.getWebGLErrorMessage());
        document.getElementById("container").innerHTML = "";
      }

      // Graphics variables
      var container, stats;
      var camera, controls, scene, renderer;
      var textureLoader;
      var clock = new THREE.Clock();

      // Physics variables
      var gravityConstant = -9.8;
      var rigidBodies = [];
      var collisionMargin = 0.005;

      init();
      // Ball
      var ballMass = 10;
      var ballRadius = 3;

      // Creating the floor
      var floor = new THREE.Mesh(
        new THREE.PlaneBufferGeometry(200, 200, 8, 8),
        new THREE.MeshPhongMaterial({ color: 0xffffff })
      );
      floor.material.side = 2 // Tells the renderer to show both sides of the floor
      floor.rotation.x = Math.PI/2

      // Creating a ball
      var ball = new THREE.Mesh(
        new THREE.SphereBufferGeometry(ballRadius, 20, 20),
        new THREE.MeshPhongMaterial({ color: 0x202020 })
      );
      ball.position.y = ballRadius + collisionMargin

      // Creating a brick
      // Abstract into function to create multiple bricks at random positions
      var brick = new THREE.Mesh(
        new THREE.BoxBufferGeometry(10, 5, 5),
        new THREE.MeshPhongMaterial({ color: 0x202020 })
      );
      brick.position.x = 30 // "A random position"
      brick.position.y = 5/2 + collisionMargin // Half the height of the brick + a margin to avoid clipping (Currently hardcoded)
      brick.rotation.y = Math.PI/2 // For inital testing we face the  rectangle towards the object
      
      scene.add(ball)
      scene.add(floor)
      scene.add(brick)
      animate();

      // Runs all our inital setup
      function init() {
        initGraphics(); // Camera and light setup.
        initInput(); // Inits our input (For shooting the cannon ball)
        // createObjects() // This function should contain all our intial objects (Bricks and floor) -> The ball will be rendered on keyDown/keyUp
        // initPhysics(); // We need to implement our own physics and collision detection
      }

      function initGraphics() {
        container = document.getElementById("container");

        camera = new THREE.PerspectiveCamera(
          80,
          window.innerWidth / window.innerHeight,
        );

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xbfd1e5);

        camera.position.set(-24, 24, -24);

        controls = new THREE.OrbitControls(camera);
        controls.target.set(0, 2, 0);
        controls.update();

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        textureLoader = new THREE.TextureLoader();

        var ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        var light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(-10, 10, 5);
        light.castShadow = true;
        var d = 10;
        light.shadow.camera.left = -d;
        light.shadow.camera.right = d;
        light.shadow.camera.top = d;
        light.shadow.camera.bottom = -d;

        light.shadow.camera.near = 2;
        light.shadow.camera.far = 50;

        light.shadow.mapSize.x = 1024;
        light.shadow.mapSize.y = 1024;

        scene.add(light);

        container.innerHTML = "";

        container.appendChild(renderer.domElement);

        stats = new Stats();
        stats.domElement.style.position = "absolute";
        stats.domElement.style.top = "0px";
        container.appendChild(stats.domElement);

        //

        window.addEventListener("resize", onWindowResize, false);
      }

      function createRandomColor() {
        return Math.floor(Math.random() * (1 << 24));
      }

      function createMaterial() {
        return new THREE.MeshPhongMaterial({ color: createRandomColor() });
      }

      function initInput() {
        window.addEventListener(
          "keydown",
          function(event) {
            switch (event.keyCode) {
              // Q
              case 81:
                // armMovement = 1;
                break;

              // A
              case 65:
                // armMovement = -1;
                break;
            }
          },
          false
        );

        window.addEventListener(
          "keyup",
          function() {
            // armMovement = 0;
          },
          false
        );
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        render();
        stats.update();
      }

      function render() {
        var deltaTime = clock.getDelta();

        //updatePhysics(deltaTime);

        renderer.render(scene, camera);
      }

      function updatePhysics(deltaTime) {

        // Step world
        physicsWorld.stepSimulation(deltaTime, 10);
    
      }
             /*******
         * THIS GENERATES A WALL *
         * 
         for (var j = 0; j < numBricksHeight; j++) {
          var oddRow = j % 2 == 1;

          pos.z = z0;

          if (oddRow) {
            pos.z -= 0.25 * brickLength;
          }

          var nRow = oddRow ? numBricksLength + 1 : numBricksLength;
          for (var i = 0; i < nRow; i++) {
            var brickLengthCurrent = brickLength;
            var brickMassCurrent = brickMass;
            if (oddRow && (i == 0 || i == nRow - 1)) {
              
            }
            
            var brick = createParalellepiped(
              brickDepth,
              brickHeight,
              brickLengthCurrent,
              brickMassCurrent,
              pos,
              quat,
              createMaterial()
            );
            brick.castShadow = true;
            brick.receiveShadow = true;

            if (oddRow && (i == 0 || i == nRow - 2)) {
              pos.z += 0.75 * brickLength;
            } else {
              pos.z += brickLength;
            }
          }
          pos.y += brickHeight;
        }*/
    </script>
  </body>
</html>



